// Generated by IcedCoffeeScript 108.0.11

/*

Параметры:

  wall_offset  - отступ от стены [мм]
  board_w      - ширина доски [мм]
  board_h      - высота доски [мм]
  room_polygon - полигон комнаты 
  room_polygon_offset - полигон комнты с отсупом 
  room_bbox    - габариты комнаты
  flooring[]   - массив ламинатин
 */
var Flooring, H, Room, W, area, clip, offset, path2svg, path_bbox, point_inside, point_inside_path, poly2svg, poly_bbox, rnd, scale_path, scale_poly, wall_offset,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

W = 800;

H = 800;

wall_offset = -10;

path2svg = function(path) {
  var svg;
  svg = path.map(function(point, j) {
    var pref;
    pref = j === 0 ? "M" : "L";
    return "" + pref + point.X + "," + point.Y;
  });
  return svg += "Z";
};

poly2svg = function(poly) {
  var svg_path;
  return svg_path = poly.reduce(function(svg, path) {
    return svg += path2svg(path);
  }, "");
};

offset = function(poly, delta) {
  var co, offseted;
  co = new ClipperLib.ClipperOffset();
  offseted = new ClipperLib.Paths();
  co.AddPaths(poly, ClipperLib.JoinType.jtMiter, ClipperLib.EndType.etClosedPolygon);
  co.MiterLimit = 10;
  co.ArcTolerance = 0.25;
  co.Execute(offseted, delta);
  return offseted;
};

scale_path = function(path, scale) {
  var p, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = path.length; _i < _len; _i++) {
    p = path[_i];
    _results.push({
      X: p.X * scale,
      Y: p.Y * scale
    });
  }
  return _results;
};

scale_poly = function(poly, scale) {
  var path, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = poly.length; _i < _len; _i++) {
    path = poly[_i];
    _results.push(scale_path(path, scale));
  }
  return _results;
};

clip = function(subj, clip) {
  var cpr, result;
  subj = scale_poly(subj, 100);
  clip = scale_poly(clip, 100);
  subj = offset(subj, -5);
  cpr = new ClipperLib.Clipper();
  cpr.AddPaths(subj, ClipperLib.PolyType.ptSubject, true);
  cpr.AddPaths(clip, ClipperLib.PolyType.ptClip, true);
  result = new ClipperLib.Paths();
  cpr.Execute(ClipperLib.ClipType.ctIntersection, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
  result = offset(result, 4);
  return result = scale_poly(result, 0.01);
};

area = function(poly) {
  return ClipperLib.JS.AreaOfPolygons(poly);
};

path_bbox = function(path) {
  var max_x, max_y, min_x, min_y;
  min_x = min_y = Infinity;
  max_x = max_y = -Infinity;
  path.map(function(p) {
    if (min_x > p.X) {
      min_x = p.X;
    }
    if (min_y > p.Y) {
      min_y = p.Y;
    }
    if (max_x < p.X) {
      max_x = p.X;
    }
    if (max_y < p.Y) {
      return max_y = p.Y;
    }
  });
  return {
    l: min_x,
    t: min_y,
    r: max_x,
    b: max_y
  };
};

poly_bbox = function(poly) {
  var bbox;
  bbox = {
    l: Infinity,
    t: Infinity,
    r: -Infinity,
    b: -Infinity
  };
  poly.map(function(path) {
    var b;
    b = path_bbox(path);
    if (bbox.l > b.l) {
      bbox.l = b.l;
    }
    if (bbox.t > b.t) {
      bbox.t = b.t;
    }
    if (bbox.r < b.r) {
      bbox.r = b.r;
    }
    if (bbox.b < b.b) {
      return bbox.b = b.b;
    }
  });
  bbox.w = bbox.r - bbox.l;
  bbox.h = bbox.b - bbox.t;
  return bbox;
};

point_inside_path = function(point, polygon) {
  var i, inside, intersect, j, x, xi, xj, y, yi, yj;
  x = point.X;
  y = point.Y;
  inside = false;
  i = 0;
  j = polygon.length - 1;
  while (i < polygon.length) {
    xi = polygon[i].X;
    yi = polygon[i].Y;
    xj = polygon[j].X;
    yj = polygon[j].Y;
    intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
    if (intersect) {
      inside = !inside;
    }
    j = i++;
  }
  return inside;
};

point_inside = function(point, poly) {
  var path, _i, _len;
  for (_i = 0, _len = poly.length; _i < _len; _i++) {
    path = poly[_i];
    if (point_inside_path(point, path)) {
      return true;
    }
  }
  return false;
};

rnd = function(r) {
  return Math.random() * r | 0;
};

Room = (function() {
  function Room(svg) {
    this.svg = svg;
    this.random = __bind(this.random, this);
    this.random();
  }

  Room.prototype.random = function() {
    var glued_path, h, i, w, x, y;
    this.group = this.svg.group();
    this.group.attr({
      transform: "scale(0.1)"
    });
    this.poly = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i <= 4; i = ++_i) {
        x = (1 + rnd(4)) * 1000;
        y = (1 + rnd(4)) * 1000;
        w = (2 + rnd(4)) * 1000;
        h = (2 + rnd(4)) * 1000;
        _results.push([
          {
            X: x,
            Y: y
          }, {
            X: x + w,
            Y: y
          }, {
            X: x + w,
            Y: y + h
          }, {
            X: x,
            Y: y + h
          }
        ]);
      }
      return _results;
    })();
    this.glued_poly = offset(this.poly, 0);
    this.bbox = poly_bbox(this.glued_poly);
    this.cx = this.bbox.l + this.bbox.w * 0.5;
    this.cy = this.bbox.t + this.bbox.h * 0.5;
    this.R = Math.sqrt(this.bbox.w * this.bbox.w + this.bbox.h * this.bbox.h) * 0.5;
    glued_path = this.svg.path(poly2svg(this.glued_poly));
    glued_path.attr({
      "vector-effect": "non-scaling-stroke",
      fill: "white",
      stroke: "gray",
      strokeWidth: 4
    });
    this.group.add(glued_path);
    this.offseted_poly = offset(this.glued_poly, wall_offset);
    this.offseted_path = this.svg.path(poly2svg(this.offseted_poly));
    this.offseted_path.attr({
      "vector-effect": "non-scaling-stroke",
      fill: "none",
      stroke: "red",
      strokeWidth: 1
    });
    return this.group.add(this.offseted_path);
  };

  return Room;

})();

Flooring = (function() {
  function Flooring(svg, room, w, h, dir, shift) {
    this.svg = svg;
    this.room = room;
    this.w = w != null ? w : 1380.0;
    this.h = h != null ? h : 190.0;
    this.dir = dir != null ? dir : 45;
    this.shift = shift != null ? shift : 0.2;
    this.mouseout = __bind(this.mouseout, this);
    this.mouseover = __bind(this.mouseover, this);
    this.details = __bind(this.details, this);
    this.draw_boundings = __bind(this.draw_boundings, this);
    this.update = __bind(this.update, this);
    this.debug = false;
    this.flooring = true;
    this.update();
  }

  Flooring.prototype.update = function() {
    var b, board, board_intersects, boards_cnt, clipped_line, create_board, cs, cx, cy, d, h, h_dx, h_dy, i, l, line, lines_cnt, p, r, show, sn, sx, sy, v_dx, v_dy, xt, _i, _j, _k, _l, _len, _len1, _m, _ref, _ref1;
    if (this.debug_layer != null) {
      this.debug_layer.clear();
    }
    if (this.boards_layer != null) {
      this.boards_layer.clear();
    }
    if (this.details_layer != null) {
      this.details_layer.clear();
    }
    if (this.debug_layer == null) {
      this.debug_layer = this.svg.group();
    }
    this.debug_layer.attr({
      visibility: this.debug ? "visible" : "hidden",
      transform: "scale(0.1)",
      fill: "gray",
      fillOpacity: "0.1",
      stroke: "gray",
      strokeWidth: 4
    });
    if (this.boards_layer == null) {
      this.boards_layer = this.svg.group();
    }
    this.boards_layer.attr({
      transform: "scale(0.1)",
      visibility: this.flooring ? "visible" : "hidden"
    });
    if (this.details_layer == null) {
      this.details_layer = this.svg.group();
    }
    xt = this.w * 0.5;
    this.R = this.room.R + xt;
    this.bbox = {
      l: this.room.bbox.l - xt,
      r: this.room.bbox.r + xt,
      t: this.room.bbox.t - xt,
      b: this.room.bbox.b + xt
    };
    this.bbox.w = this.bbox.r - this.bbox.l;
    this.bbox.h = this.bbox.b - this.bbox.t;
    lines_cnt = this.R * 2.0 / this.h;
    this.dir_r = this.dir / 180.0 * Math.PI;
    sn = Math.sin(this.dir_r);
    cs = Math.cos(this.dir_r);
    h_dx = this.w * cs;
    h_dy = -this.w * sn;
    v_dx = this.h * sn;
    v_dy = this.h * cs;
    sx = this.room.cx - this.R * sn;
    sy = this.room.cy - this.R * cs;
    this.draw_boundings();
    board_intersects = (function(_this) {
      return function(board, bbox) {
        var p, _i, _len, _ref, _ref1;
        for (_i = 0, _len = board.length; _i < _len; _i++) {
          p = board[_i];
          if ((bbox.l < (_ref = p.X) && _ref < bbox.r) && (bbox.t < (_ref1 = p.Y) && _ref1 < bbox.b)) {
            return true;
          }
        }
        return false;
      };
    })(this);
    create_board = (function(_this) {
      return function(cx, cy) {
        var board, bp, inside, point, points, _i, _len;
        board = [
          {
            X: cx + (-h_dx - v_dx) * 0.5,
            Y: cy + (-h_dy - v_dy) * 0.5
          }, {
            X: cx + (+h_dx - v_dx) * 0.5,
            Y: cy + (+h_dy - v_dy) * 0.5
          }, {
            X: cx + (+h_dx + v_dx) * 0.5,
            Y: cy + (+h_dy + v_dy) * 0.5
          }, {
            X: cx + (-h_dx + v_dx) * 0.5,
            Y: cy + (-h_dy + v_dy) * 0.5
          }
        ];
        points = [
          board[0], board[1], board[2], board[3], {
            X: cx - v_dx * 0.5,
            Y: cy - v_dy * 0.5
          }, {
            X: cx + v_dx * 0.5,
            Y: cy + v_dy * 0.5
          }, {
            X: cx + (-h_dx * 0.5 - v_dx) * 0.5,
            Y: cy + (-h_dy * 0.5 - v_dy) * 0.5
          }, {
            X: cx + (+h_dx * 0.5 - v_dx) * 0.5,
            Y: cy + (+h_dy * 0.5 - v_dy) * 0.5
          }, {
            X: cx + (+h_dx * 0.5 + v_dx) * 0.5,
            Y: cy + (+h_dy * 0.5 + v_dy) * 0.5
          }, {
            X: cx + (-h_dx * 0.5 + v_dx) * 0.5,
            Y: cy + (-h_dy * 0.5 + v_dy) * 0.5
          }
        ];
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          point = points[_i];
          inside = point_inside(point, _this.room.glued_poly);
          if (inside) {
            bp = _this.svg.path(path2svg(board));
            _this.debug_layer.add(bp);
            return board;
          }
        }
        return void 0;
      };
    })(this);
    this.boards = [];
    this.counter = 0;
    for (l = _i = 1, _ref = lines_cnt - 1; 1 <= _ref ? _i < _ref : _i > _ref; l = 1 <= _ref ? ++_i : --_i) {
      d = this.R - this.h * l;
      h = Math.sqrt(this.R * this.R - d * d);
      cx = sx + v_dx * l;
      cy = sy + v_dy * l;
      switch (l % 5) {
        case 1:
          cx += h_dx * 2.0 / 3.0;
          cy += h_dy * 2.0 / 3.0;
          break;
        case 2:
          cx += h_dx / 4.0;
          cy += h_dy / 4.0;
          break;
        case 3:
          cx += h_dx * 3.0 / 4.0;
          cy += h_dy * 3.0 / 4.0;
          break;
        case 4:
          cx += h_dx / 2.0;
          cy += h_dy / 2.0;
      }
      this.debug_layer.add(this.svg.circle(cx, cy, 40));
      this.debug_layer.add(this.svg.line(cx - cs * h, cy + sn * h, cx + cs * h, cy - sn * h));
      boards_cnt = h / this.w | 0;
      line = [];
      for (r = _j = 0; 0 <= boards_cnt ? _j <= boards_cnt : _j >= boards_cnt; r = 0 <= boards_cnt ? ++_j : --_j) {
        b = create_board(cx + h_dx * r, cy + h_dy * r);
        if (b) {
          line.push(b);
          this.counter++;
        }
      }
      for (r = _k = -1; -1 <= -boards_cnt ? _k <= -boards_cnt : _k >= -boards_cnt; r = -1 <= -boards_cnt ? ++_k : --_k) {
        b = create_board(cx + h_dx * r, cy + h_dy * r);
        if (b) {
          line.push(b);
          this.counter++;
        }
      }
      this.boards.push(line);
    }
    i = 0;
    _ref1 = this.boards;
    for (_l = 0, _len = _ref1.length; _l < _len; _l++) {
      line = _ref1[_l];
      clipped_line = clip(line, this.room.offseted_poly);
      for (_m = 0, _len1 = clipped_line.length; _m < _len1; _m++) {
        board = clipped_line[_m];
        p = this.svg.path(path2svg(board));
        p.attr({
          "vector-effect": "non-scaling-stroke",
          fill: "#A88",
          fillOpacity: "0.0",
          stroke: "#422",
          strokeWidth: "1.0",
          strokeOpacity: "0.0"
        });
        p.node.element = p;
        show = (function(_this) {
          return function(p) {
            p.attr({
              cursor: "pointer",
              fillOpacity: "1.0",
              strokeOpacity: "1.0"
            });
            p.mouseover(_this.mouseover);
            return p.mouseout(_this.mouseout);
          };
        })(this);
        setTimeout(show, (i++) * 25, p);
        this.boards_layer.add(p);
      }
    }
    if (this.text != null) {
      this.text.remove();
    }
    this.text = this.svg.text(20, 44, "S: " + (area(this.room.glued_poly) / 1e6) + "м², ~" + (Math.ceil(this.counter / 8)) + " пачек (" + this.counter + "шт) ");
    return this.text.attr({
      fontSize: 28
    });
  };

  Flooring.prototype.draw_boundings = function() {
    var circle, rect;
    rect = this.svg.rect(this.bbox.l, this.bbox.t, this.bbox.w, this.bbox.h);
    rect.attr({
      "vector-effect": "non-scaling-stroke",
      fill: "none",
      stroke: "gray",
      strokeWidth: "1"
    });
    this.debug_layer.add(rect);
    circle = this.svg.circle(this.room.cx, this.room.cy, this.R);
    circle.attr({
      "vector-effect": "non-scaling-stroke",
      fill: "none",
      stroke: "gray",
      strokeWidth: "1"
    });
    return this.debug_layer.add(circle);
  };

  Flooring.prototype.details = function(path) {
    var angle, bbox, cx, cy, d, dx, dy, i, j, ln, maxx, maxy, minx, miny, p, points, t, _i, _j, _ref, _ref1;
    d = path.attr("d");
    points = d.replace(/[^,.0-9]/g, '').split(',').map(function(n) {
      return parseFloat(n);
    });
    minx = maxx = points[0];
    miny = maxy = points[1];
    for (i = _i = 2, _ref = points.length; _i < _ref; i = _i += 2) {
      if (minx > points[i + 0]) {
        minx = points[i + 0];
      }
      if (miny > points[i + 1]) {
        miny = points[i + 1];
      }
      if (maxx < points[i + 0]) {
        maxx = points[i + 0];
      }
      if (maxy < points[i + 1]) {
        maxy = points[i + 1];
      }
    }
    cx = (maxx + minx) * 0.5;
    cy = (maxy + miny) * 0.5;
    path = (function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = points.length; _j < _ref1; i = _j += 2) {
        _results.push({
          X: points[i + 0] - cx,
          Y: points[i + 1] - cy
        });
      }
      return _results;
    })();
    p = this.svg.path(path2svg(path));
    p.attr({
      transform: "rotate(" + (this.dir + 90) + ")",
      stroke: "#422",
      strokeWidth: 6,
      fill: "#A88"
    });
    bbox = p.getBBox();
    p.attr({
      transform: "translate(" + (-bbox.x) + " " + (-bbox.y) + ") rotate(" + (this.dir + 90) + ")"
    });
    this.details_layer.clear();
    this.details_layer.add(p);
    for (i = _j = 0, _ref1 = path.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
      j = i + 1;
      j %= path.length;
      dx = path[i].X - path[j].X;
      dy = path[i].Y - path[j].Y;
      ln = Math.sqrt(dx * dx + dy * dy);
      cx = (path[i].X + path[j].X) * 0.5;
      cy = (path[i].Y + path[j].Y) * 0.5;
      angle = Math.atan2(dx, dy) * 180.0 / Math.PI;
      t = this.svg.text(cx, cy - 10, "" + ((ln + 1) | 0) + " мм");
      t.attr({
        transform: "translate(" + (-bbox.x) + " " + (-bbox.y) + ") rotate(" + (this.dir + 90) + ") rotate(" + (-90 - angle) + " " + cx + " " + cy + ")",
        textAnchor: "middle",
        fontSize: 24
      });
      this.details_layer.add(t);
    }
    return this.details_layer.attr({
      transform: "translate(" + (this.bbox.r * 0.1) + ", " + (this.bbox.t * 0.1) + ") scale(0.5) "
    });
  };

  Flooring.prototype.mouseover = function(e) {
    var el;
    el = e.target.element;
    el.animate({
      fillOpacity: "0.75"
    }, 200);
    return this.details(el);
  };

  Flooring.prototype.mouseout = function(e) {
    var el;
    el = e.target.element;
    el.animate({
      fillOpacity: "1.0"
    }, 200);
    return this.details_layer.clear();
  };

  Flooring.prototype.mousedown = function() {};

  return Flooring;

})();

$(function() {
  var flooring, gui, room, svg;
  svg = Snap("100%", "100%");
  room = new Room(svg);
  flooring = new Flooring(svg, room);
  gui = new dat.GUI();
  gui.add(flooring, "dir", 0, 360, 15).onFinishChange(function(v) {
    return flooring.update();
  });
  gui.add(flooring, "shift", 0.01, 0.5, 0.01).onFinishChange(function(v) {
    return flooring.update();
  });
  gui.add(flooring, "w", 200, 2000, 10).onFinishChange(function(v) {
    return flooring.update();
  });
  gui.add(flooring, "h", 200, 2000, 10).onFinishChange(function(v) {
    return flooring.update();
  });
  gui.add(flooring, "debug").onChange(function(v) {
    var visibility;
    visibility = v ? "visible" : "hidden";
    return flooring.debug_layer.attr({
      visibility: visibility
    });
  });
  return gui.add(flooring, "flooring").onChange(function(v) {
    var visibility;
    visibility = v ? "visible" : "hidden";
    return flooring.boards_layer.attr({
      visibility: visibility
    });
  });
});
